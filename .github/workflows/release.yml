name: Create GitHub Release and Package

on:
  push:
    tags:
      - "v*" # Push events to matching v*, i.e. v1.0.0, v20.15.10
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to release from (e.g., main, develop, feature/xyz, fix/abc)'
        required: true
        default: 'main'
      is_prerelease_override:
        description: 'Manually mark as prerelease (true/false). If empty, auto-detect based on branch/GitVersion.'
        required: false
        type: boolean
      specific_version:
        description: 'Optional: Specify an exact version to use (e.g., 1.2.3-beta.1). Overrides GitVersion branch calculation.'
        required: false

permissions:
  contents: write # Needed for creating GitHub releases and potentially pushing tags

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.gitversion.outputs.semVer }}
      is_prerelease: ${{ steps.determine_prerelease_flag.outputs.is_prerelease }}
      # The actual tag created/used for the release will be 'v' + semVer
      release_tag_name: v${{ steps.gitversion.outputs.semVer }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for GitVersion
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.301"

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0.10.2
        with:
          versionSpec: "6.x"

      - name: Determine version
        id: gitversion
        run: |
          if [ -n "${{ github.event.inputs.specific_version }}" ]; then
            echo "Using specific version from input: ${{ github.event.inputs.specific_version }}"
            # Ensure specific_version is directly usable as SemVer
            RAW_VERSION="${{ github.event.inputs.specific_version }}"
            # Remove 'v' prefix if present
            CLEAN_VERSION=${RAW_VERSION#v}

            echo "semVer=$CLEAN_VERSION" >> $GITHUB_OUTPUT

            VERSION_BASE=$(echo "$CLEAN_VERSION" | cut -d'-' -f1)
            PRE_RELEASE_TAG=$(echo "$CLEAN_VERSION" | cut -s -d'-' -f2-)

            echo "majorMinorPatch=$VERSION_BASE" >> $GITHUB_OUTPUT
            echo "nuGetVersion=$CLEAN_VERSION" >> $GITHUB_OUTPUT # Assuming NuGetVersion is same as SemVer for specific inputs
            if [ -n "$PRE_RELEASE_TAG" ]; then
              echo "preReleaseTag=$PRE_RELEASE_TAG" >> $GITHUB_OUTPUT
            else
              echo "preReleaseTag=" >> $GITHUB_OUTPUT # Ensure it's empty string if no prerelease part
            fi
            # For FullSemVer, if it's a manual override, it's likely just the SemVer itself unless more complex logic is needed
            echo "fullSemVer=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          else
            # Execute GitVersion, capturing all its output variables
            # Ensure GitVersion tool is directly callable after setup action
            GITVERSION_JSON=$(dotnet-gitversion /output json /config GitVersion.yml)
            echo "GitVersion JSON: $GITVERSION_JSON"
            echo "semVer=$(echo $GITVERSION_JSON | jq -r .SemVer)" >> $GITHUB_OUTPUT
            echo "majorMinorPatch=$(echo $GITVERSION_JSON | jq -r .MajorMinorPatch)" >> $GITHUB_OUTPUT
            echo "nuGetVersion=$(echo $GITVERSION_JSON | jq -r .NuGetVersion)" >> $GITHUB_OUTPUT
            echo "preReleaseTag=$(echo $GITVERSION_JSON | jq -r .PreReleaseTag)" >> $GITHUB_OUTPUT
            echo "fullSemVer=$(echo $GITVERSION_JSON | jq -r .FullSemVer)" >> $GITHUB_OUTPUT
            # Update assembly info using GitVersion's recommended way
            dotnet-gitversion /updateassemblyinfo true
          fi
        shell: bash

      - name: Display Version Info
        run: |
          echo "SemVer: ${{ steps.gitversion.outputs.semVer }}"
          echo "MajorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}"
          echo "NuGetVersion: ${{ steps.gitversion.outputs.nuGetVersion }}"
          echo "PreReleaseTag: ${{ steps.gitversion.outputs.preReleaseTag }}"
          echo "FullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}"

      - name: Tag commit if manually triggered and tag doesn't exist
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION_TAG="v${{ steps.gitversion.outputs.semVer }}"
          # Check if tag exists remotely or locally
          if ! git rev-parse -q --verify "refs/tags/$VERSION_TAG" && ! git ls-remote --tags origin "refs/tags/$VERSION_TAG" | grep -q "refs/tags/$VERSION_TAG"; then
            echo "Tag $VERSION_TAG does not exist. Creating tag..."
            git config user.name "${{ github.actor }}"
            git config user.email "${{ github.actor }}@users.noreply.github.com"
            git tag -a "$VERSION_TAG" -m "Release $VERSION_TAG"
            git push origin "$VERSION_TAG"
            echo "Pushed tag $VERSION_TAG"
          else
            echo "Tag $VERSION_TAG already exists."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Prerelease Flag
        id: determine_prerelease_flag
        run: |
          IS_PRERELEASE="false"
          # Priority 1: Manual override from input
          if [ "${{ github.event.inputs.is_prerelease_override }}" == "true" ]; then
            IS_PRERELEASE="true"
          elif [ "${{ github.event.inputs.is_prerelease_override }}" == "false" ]; then
            # Explicitly set to false if override is 'false'
            IS_PRERELEASE="false"
          # Priority 2: GitVersion's PreReleaseTag (check if not null and not empty)
          elif [ -n "${{ steps.gitversion.outputs.preReleaseTag }}" ] && [ "${{ steps.gitversion.outputs.preReleaseTag }}" != "null" ]; then
            IS_PRERELEASE="true"
          # Priority 3: If triggered by workflow_dispatch and branch is not main (safer default for non-main branches)
          # Ensure branch input is correctly evaluated
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.branch }}" != "main" ]]; then
            IS_PRERELEASE="true"
          # Priority 4: If triggered by a tag, check if the tag name contains a hyphen (like v1.0.0-beta)
          # This handles the case where a pre-release tag (e.g. v1.2.3-beta.1) is pushed directly
          elif [[ "${{ github.ref_type }}" == "tag" && "${{ github.ref_name }}" == *"-"* ]]; then
            IS_PRERELEASE="true"
          fi
          echo "is_prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "Determined is_prerelease: ${IS_PRERELEASE}"


      - name: Restore dependencies
        run: dotnet restore

      - name: Build Release
        run: dotnet build --configuration Release --no-restore /p:Version=${{ steps.gitversion.outputs.semVer }} /p:PackageVersion=${{ steps.gitversion.outputs.nuGetVersion }}

      - name: Pack NuGet package
        run: dotnet pack --configuration Release --no-build -o ./artifacts /p:Version=${{ steps.gitversion.outputs.semVer }} /p:PackageVersion=${{ steps.gitversion.outputs.nuGetVersion }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.gitversion.outputs.semVer }} # Use the SemVer from GitVersion for the tag name
          name: ${{ steps.determine_prerelease_flag.outputs.is_prerelease == 'true' && 'Pre-release' || 'Release' }} v${{ steps.gitversion.outputs.semVer }}
          body: |
            Automated release for version v${{ steps.gitversion.outputs.semVer }}.
            ${{ github.event_name == 'workflow_dispatch' && format('Triggered manually by {0} from branch {1}.', github.actor, github.event.inputs.branch) || format('Triggered by tag push {0}.', github.ref_name) }}

            **Version Details:**
            - SemVer: `${{ steps.gitversion.outputs.semVer }}`
            - FullSemVer: `${{ steps.gitversion.outputs.fullSemVer }}`
            - NuGetVersion: `${{ steps.gitversion.outputs.nuGetVersion }}`
            - Pre-release Tag: `${{ steps.gitversion.outputs.preReleaseTag || 'N/A' }}`
          files: |
            ./artifacts/*.nupkg
            ./artifacts/*.snupkg
          draft: false
          prerelease: ${{ steps.determine_prerelease_flag.outputs.is_prerelease == 'true' }}
          # Generate release notes only for actual tag pushes to avoid issues with dispatch/manual tags
          generate_release_notes: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload NuGet Package as artifact
        uses: actions/upload-artifact@v4
        with:
          name: nuget-package-${{ steps.gitversion.outputs.semVer }}
          path: |
            ./artifacts/*.nupkg
            ./artifacts/*.snupkg
          retention-days: 30

  call-docker-build:
    name: Build and Push Docker Image
    needs: release # Depends on the successful completion of the release job
    runs-on: ubuntu-latest
    # Ensure this job runs only if the 'release' job succeeded and produced a version.
    if: always() && needs.release.result == 'success' && needs.release.outputs.version
    # Pass secrets required by the callable workflow
    secrets: inherit # This will pass DOCKER_USERNAME and DOCKER_PASSWORD if defined in the environment or repo secrets

    steps:
      - name: Determine Docker Tags
        id: docker_tags
        run: |
          VERSION="${{ needs.release.outputs.version }}"
          IS_PRERELEASE="${{ needs.release.outputs.is_prerelease }}"
          ADDITIONAL_TAGS=""

          # For full releases (non-prerelease, typically from main)
          if [[ "$IS_PRERELEASE" == "false" ]]; then
            ADDITIONAL_TAGS="latest" # Add 'latest' tag
            # Add 'major.minor' and 'major' tags
            MAJOR_MINOR=$(echo "$VERSION" | awk -F. '{print $1"."$2}')
            MAJOR=$(echo "$VERSION" | awk -F. '{print $1}')
            if [ -n "$MAJOR_MINOR" ]; then ADDITIONAL_TAGS="$ADDITIONAL_TAGS,$MAJOR_MINOR"; fi
            if [ -n "$MAJOR" ]; then ADDITIONAL_TAGS="$ADDITIONAL_TAGS,$MAJOR"; fi
          fi
          echo "Base version tag: $VERSION"
          echo "Calculated additional tags: $ADDITIONAL_TAGS"
          # Store for use in the next step
          echo "additional_tags_list=$ADDITIONAL_TAGS" >> $GITHUB_OUTPUT

      - name: Call Build and Push Image Workflow
        uses: ./.github/workflows/build-and-push-image.yml
        with:
          image_name: 'metaneutrons/snapdog' # Replace with your actual image name
          version: ${{ needs.release.outputs.version }} # This is the SemVer from the release job
          additional_tags: ${{ steps.docker_tags.outputs.additional_tags_list }}
          # dockerfile_path and context_path use defaults from callable workflow
        # Secrets are passed via 'secrets: inherit' on the job level
        # If specific secrets mapping is needed:
        # secrets:
        #   DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME_REPO_LEVEL_OR_ENV }}
        #   DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD_REPO_LEVEL_OR_ENV }}
